{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Iodine is a functional UI toolkit for Kotlin built on top of Flow , Jetpack Compose , and Arrow . Where Arrow intends to be a \"Functional companion to Kotlin's Standard Library\", Iodine aims to be a functional companion to Jetpack Compose (including for desktop and multi-platform targets). To get started, check out basic concepts for a short introduction to some of core concepts and types used by Iodine -- or examples for some concrete examples of how to build up some basic applications with Iodine components. Background Declarative functional UI programming has a long and varied history, going back to at least to the Fudgets library in the 1990s. More recently, in the 2010s, the React framework popularized functional declarative UI programming in the Javascript ecosystem. Since then, there have been a number of different approaches to this paradigm, from the popular to the more obscure -- in many languages and platforms. Amidst this great array of diversity and complexity, a common organizing principle is the idea of a Component . To quote the documentation from Halogen : Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications. Iodine takes heavily from the ideas of the Halogen framework ( iodine is a type of halogen , after all) -- in particular, the idea of using generic parameters to expose the public API of a UI component. From there, the approaches diverge somewhat. Whereas Halogen is designed to work well in a purely functional language , with support for some helpful but not very commonly implemented type system features , Iodine is designed with similar goals in mind, but implemented in a way as to work more idiomatically with Kotlin's multi-paradigm philosophy -- and to take advantage of features unique to Kotlin, such as typesafe builder DSLs and functions with receivers. Another strain of ideas that Iodine is inspired by the idea of using comonads to model user interface (c.f. Declarative UIs are the Future \u2014 And the Future is Comonadic! , Phil Friedman, 2018). A similar approach is taken by the Swift framework Bow Arch . Direct support for this style of programming is provided by the iodine-core-comonadic-ui package.","title":"Introduction"},{"location":"#introduction","text":"Iodine is a functional UI toolkit for Kotlin built on top of Flow , Jetpack Compose , and Arrow . Where Arrow intends to be a \"Functional companion to Kotlin's Standard Library\", Iodine aims to be a functional companion to Jetpack Compose (including for desktop and multi-platform targets). To get started, check out basic concepts for a short introduction to some of core concepts and types used by Iodine -- or examples for some concrete examples of how to build up some basic applications with Iodine components.","title":"Introduction"},{"location":"#background","text":"Declarative functional UI programming has a long and varied history, going back to at least to the Fudgets library in the 1990s. More recently, in the 2010s, the React framework popularized functional declarative UI programming in the Javascript ecosystem. Since then, there have been a number of different approaches to this paradigm, from the popular to the more obscure -- in many languages and platforms. Amidst this great array of diversity and complexity, a common organizing principle is the idea of a Component . To quote the documentation from Halogen : Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications. Iodine takes heavily from the ideas of the Halogen framework ( iodine is a type of halogen , after all) -- in particular, the idea of using generic parameters to expose the public API of a UI component. From there, the approaches diverge somewhat. Whereas Halogen is designed to work well in a purely functional language , with support for some helpful but not very commonly implemented type system features , Iodine is designed with similar goals in mind, but implemented in a way as to work more idiomatically with Kotlin's multi-paradigm philosophy -- and to take advantage of features unique to Kotlin, such as typesafe builder DSLs and functions with receivers. Another strain of ideas that Iodine is inspired by the idea of using comonads to model user interface (c.f. Declarative UIs are the Future \u2014 And the Future is Comonadic! , Phil Friedman, 2018). A similar approach is taken by the Swift framework Bow Arch . Direct support for this style of programming is provided by the iodine-core-comonadic-ui package.","title":"Background"},{"location":"concepts/basic_concepts/","text":"Basic Concepts The two basic concepts that Iodine makes use of is that of a Component , and that of a View Model . Roughly speaking, a Component is reusable bundle of behavior and a view (i.e. a @Composable fun ) of that behavior's internal state . Oftentimes, it may be convinient to keep the \"pure\" UI behavior logic decoupled from the actual way in which such logic is rendered -- for this purpose, we have the concept of a ViewModel . A ViewModel is pretty much what it sounds like -- a model of a view, or in our case a Component . View models and Components To start, let's dig into how Iodine defines a ViewModel : interface Settable<in A> { fun setValue(newValue: A) { } } interface ViewModel<out I, out E, S, in A>: Settable<A> { val impl: I val events: Flow<E> val state: StateFlow<S> } Theoretically, Iodine could have just gotten away with using I here -- as most view models as used in UI design patterns such as Model-View-ViewModel are just plain old interfaces. However, for convinience, we decided to break up the idea of a view model into three distinct components: I : The \"core\" interface of the ViewModel -- this should be an interface that describes methods that can be used to interact with the view model. E : The type of events that this view model can emit asynchronously at any time. Again, this could be construed as just another method of I -- but as this is such a common feature of view models, we reify the type E as a seperate part of the API. S : The type of internal state used by the view model. Usually, in a traditional view model, this would be a private part of the implementation of the API. However, for an Iodine ViewModel , we expose this inner state as a reactive StateFlow<S> so this view model can be bound to a rendering function to produce a full Component . Component s are just like view models, but together with a function for rendering the state of the ViewModel . Once a ViewModel has been bound to a mechanism for rendering it's state, there is no longer a reason to care about the state type S . Thus, whereas a ComponentImpl is defined as follows: interface ComponentImpl<out Ctx, out I, out E, S, in A>: ViewModel<I,E,S,A> { @Composable fun contents(state: S) } most of the time we want to use a Component , we want to keep the internal state S encapsulated . This can be accomplished with a star projection, which is how Iodine defines an honest-to-goodness Component : typealias Component<Ctx,I,E,A> = ComponentImpl<Ctx,I,E,*,A>","title":"Basic concepts"},{"location":"concepts/basic_concepts/#basic-concepts","text":"The two basic concepts that Iodine makes use of is that of a Component , and that of a View Model . Roughly speaking, a Component is reusable bundle of behavior and a view (i.e. a @Composable fun ) of that behavior's internal state . Oftentimes, it may be convinient to keep the \"pure\" UI behavior logic decoupled from the actual way in which such logic is rendered -- for this purpose, we have the concept of a ViewModel . A ViewModel is pretty much what it sounds like -- a model of a view, or in our case a Component .","title":"Basic Concepts"},{"location":"concepts/basic_concepts/#view-models-and-components","text":"To start, let's dig into how Iodine defines a ViewModel : interface Settable<in A> { fun setValue(newValue: A) { } } interface ViewModel<out I, out E, S, in A>: Settable<A> { val impl: I val events: Flow<E> val state: StateFlow<S> } Theoretically, Iodine could have just gotten away with using I here -- as most view models as used in UI design patterns such as Model-View-ViewModel are just plain old interfaces. However, for convinience, we decided to break up the idea of a view model into three distinct components: I : The \"core\" interface of the ViewModel -- this should be an interface that describes methods that can be used to interact with the view model. E : The type of events that this view model can emit asynchronously at any time. Again, this could be construed as just another method of I -- but as this is such a common feature of view models, we reify the type E as a seperate part of the API. S : The type of internal state used by the view model. Usually, in a traditional view model, this would be a private part of the implementation of the API. However, for an Iodine ViewModel , we expose this inner state as a reactive StateFlow<S> so this view model can be bound to a rendering function to produce a full Component . Component s are just like view models, but together with a function for rendering the state of the ViewModel . Once a ViewModel has been bound to a mechanism for rendering it's state, there is no longer a reason to care about the state type S . Thus, whereas a ComponentImpl is defined as follows: interface ComponentImpl<out Ctx, out I, out E, S, in A>: ViewModel<I,E,S,A> { @Composable fun contents(state: S) } most of the time we want to use a Component , we want to keep the internal state S encapsulated . This can be accomplished with a star projection, which is how Iodine defines an honest-to-goodness Component : typealias Component<Ctx,I,E,A> = ComponentImpl<Ctx,I,E,*,A>","title":"View models and Components"},{"location":"concepts/comonadic_components/","text":"Comonadic Components Now that we've introduced the basic idea of what a component is in Iodine, let's take a look at how comonads ome into the picture. For those not interested in the theory, continue on to the subsections of this section to see some examples of how this can be used. ... Store Components data class Store<S, A>( val state: S, val view: (S) -> A ) Moore Components data class Moore<E, A>( val value: A, val next: (E) -> Moore<E, A> ) Cofree Components data class Cofree<F, A>( val state: A, val next: Hk<F, Cofree<F,A>> )","title":"Comonadic components"},{"location":"concepts/comonadic_components/#comonadic-components","text":"Now that we've introduced the basic idea of what a component is in Iodine, let's take a look at how comonads ome into the picture. For those not interested in the theory, continue on to the subsections of this section to see some examples of how this can be used. ...","title":"Comonadic Components"},{"location":"concepts/comonadic_components/#store-components","text":"data class Store<S, A>( val state: S, val view: (S) -> A )","title":"Store Components"},{"location":"concepts/comonadic_components/#moore-components","text":"data class Moore<E, A>( val value: A, val next: (E) -> Moore<E, A> )","title":"Moore Components"},{"location":"concepts/comonadic_components/#cofree-components","text":"data class Cofree<F, A>( val state: A, val next: Hk<F, Cofree<F,A>> )","title":"Cofree Components"},{"location":"concepts/profunctor_optics/","text":"Profunctor optics In addition to comonads, another concept from the pure functional programming community that Iodine makes use of is that of profunctors and profunctor optics .","title":"Profunctor optics"},{"location":"concepts/profunctor_optics/#profunctor-optics","text":"In addition to comonads, another concept from the pure functional programming community that Iodine makes use of is that of profunctors and profunctor optics .","title":"Profunctor optics"},{"location":"examples/basic_examples/","text":"Examples Building a basic component Input validation One common problem often that has to be addressed when building graphical user interfaces is how to handle form input validation . Iodine provides a couple of utility classes for dealing with exactly this problem. For example, consider the following example for how to build a component with input validation for a textbox entry for an integer. // Example Component object: ValidatingStoreComponent<String, Int, InvalidInteger>(initialValue) { override fun view(input: String) = input.toIntOrNull()?.let { Either.Right(it) } ?: Either.Left(InvalidInteger) @Composable override fun contents(error: InvalidInteger?, contents: String) { Column { TextField( value = contents, onValueChange = { newValue -> ctx.defaultScope.launch { mutInput.emit(newValue) } }, label = { Text(\"\") } ) if (error == InvalidInteger) { Text( text = \"Not a valid integer\", color = Color.Red, fontSize = 16.sp ) } } Combining components","title":"Basic examples"},{"location":"examples/basic_examples/#examples","text":"","title":"Examples"},{"location":"examples/basic_examples/#building-a-basic-component","text":"","title":"Building a basic component"},{"location":"examples/basic_examples/#input-validation","text":"One common problem often that has to be addressed when building graphical user interfaces is how to handle form input validation . Iodine provides a couple of utility classes for dealing with exactly this problem. For example, consider the following example for how to build a component with input validation for a textbox entry for an integer. // Example Component object: ValidatingStoreComponent<String, Int, InvalidInteger>(initialValue) { override fun view(input: String) = input.toIntOrNull()?.let { Either.Right(it) } ?: Either.Left(InvalidInteger) @Composable override fun contents(error: InvalidInteger?, contents: String) { Column { TextField( value = contents, onValueChange = { newValue -> ctx.defaultScope.launch { mutInput.emit(newValue) } }, label = { Text(\"\") } ) if (error == InvalidInteger) { Text( text = \"Not a valid integer\", color = Color.Red, fontSize = 16.sp ) } }","title":"Input validation"},{"location":"examples/basic_examples/#combining-components","text":"","title":"Combining components"},{"location":"examples/calculator_app/","text":"Building a calculator app","title":"Calculator app"},{"location":"examples/calculator_app/#building-a-calculator-app","text":"","title":"Building a calculator app"},{"location":"examples/todo_app/","text":"Building a Todo app","title":"Todo app"},{"location":"examples/todo_app/#building-a-todo-app","text":"","title":"Building a Todo app"}]}