{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Iodine is a functional UI toolkit for Kotlin built on top of Flow , Jetpack Compose , and Arrow . Where Arrow intends to be a \"Functional companion to Kotlin's Standard Library\", Iodine aims to be a functional companion to Jetpack Compose (including for desktop and multi-platform targets). Iodine makes use of a component-based architecture , while also taking some inspirations from traditionally object-oriented approaches such as Model-View-ViewModel . To get started, check out basic concepts for a short introduction to some of core concepts and types used by Iodine -- or examples for some concrete examples of how to build up some basic applications with Iodine components. Background Declarative functional UI programming has a long and varied history, going back to at least to the Fudgets library in the 1990s. More recently, in the 2010s, the React framework popularized functional declarative UI programming in the Javascript ecosystem. Since then, there have been a number of different approaches to this paradigm, from the popular to the more obscure -- in many languages and platforms. Amidst this great array of diversity and complexity, a common organizing principle is the idea of a Component . To quote the documentation from Halogen : Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications. Iodine takes heavily from the ideas of the Halogen framework ( iodine is a type of halogen , after all) -- in particular, the idea of using generic parameters to expose the public API of a UI component. From there, the approaches diverge somewhat. Whereas Halogen is designed to work well in a purely functional language , with support for some helpful but not very commonly implemented type system features , Iodine is designed with similar goals in mind, but implemented in a way as to work more idiomatically with Kotlin's multi-paradigm philosophy -- and to take advantage of features unique to Kotlin, such as typesafe builder DSLs and functions with receivers. Users coming from the Halogen library might want to take a look at a more in-depth comparison . Another strain of ideas that Iodine is inspired by the idea of using comonads to model user interface (c.f. Declarative UIs are the Future \u2014 And the Future is Comonadic! , Phil Friedman, 2018). A similar approach is taken by the Swift framework Bow Arch . Direct support for this style of programming is provided by the iodine-core-comonadic-ui package.","title":"Introduction"},{"location":"#introduction","text":"Iodine is a functional UI toolkit for Kotlin built on top of Flow , Jetpack Compose , and Arrow . Where Arrow intends to be a \"Functional companion to Kotlin's Standard Library\", Iodine aims to be a functional companion to Jetpack Compose (including for desktop and multi-platform targets). Iodine makes use of a component-based architecture , while also taking some inspirations from traditionally object-oriented approaches such as Model-View-ViewModel . To get started, check out basic concepts for a short introduction to some of core concepts and types used by Iodine -- or examples for some concrete examples of how to build up some basic applications with Iodine components.","title":"Introduction"},{"location":"#background","text":"Declarative functional UI programming has a long and varied history, going back to at least to the Fudgets library in the 1990s. More recently, in the 2010s, the React framework popularized functional declarative UI programming in the Javascript ecosystem. Since then, there have been a number of different approaches to this paradigm, from the popular to the more obscure -- in many languages and platforms. Amidst this great array of diversity and complexity, a common organizing principle is the idea of a Component . To quote the documentation from Halogen : Halogen uses a component architecture. That means that Halogen uses components to let you split your UI into independent, reusable pieces and think about each piece in isolation. You can then combine components together to produce sophisticated applications. Iodine takes heavily from the ideas of the Halogen framework ( iodine is a type of halogen , after all) -- in particular, the idea of using generic parameters to expose the public API of a UI component. From there, the approaches diverge somewhat. Whereas Halogen is designed to work well in a purely functional language , with support for some helpful but not very commonly implemented type system features , Iodine is designed with similar goals in mind, but implemented in a way as to work more idiomatically with Kotlin's multi-paradigm philosophy -- and to take advantage of features unique to Kotlin, such as typesafe builder DSLs and functions with receivers. Users coming from the Halogen library might want to take a look at a more in-depth comparison . Another strain of ideas that Iodine is inspired by the idea of using comonads to model user interface (c.f. Declarative UIs are the Future \u2014 And the Future is Comonadic! , Phil Friedman, 2018). A similar approach is taken by the Swift framework Bow Arch . Direct support for this style of programming is provided by the iodine-core-comonadic-ui package.","title":"Background"},{"location":"additional/halogen_comparison/","text":"Comparison with Halogen If you're coming from Halogen , you will find Iodine very similar. Iodine takes a lot of cues from Halogen, but there are a few important differences to note. Interfaces as query Veterans of Halogen are sure to notice the lack of the query parameter of H.Component in Iodine's components. That is because it has been replaced with an interaction interface I. Now, I know what some of you might be thinking: gasp ! * clutches functional pearls* -- How could one possibly replace the higher-kinded query : * -> * -> * with a simple interface? To which I respond: Don't worry -- this actually has a bit of precedent, and interesting theory behind it. So if you need to legitimize your functional street cred, just be sure to mention something about the \"van Laarhoven Free Monad\". Also, to be fair, we still do need higher kinds when defining the component -- let me explain. It turns out that the Kotlin type I.() -> A , where I is an interface, is almost like a free monad. This is not quite as powerful as the van Laarhoven encoding mentioned above, but close enough for our use-case of I as a parameter for describing the API for interacting with a typed comonent (hence, interaction interface ). Even better -- it turns out that I is pretty close to what we need in order to interpret our \"free-ish\" monad I.() -> A -- that is, a cofree comonad . However, this is where higher-kinds are nescesary for our use-case. In Iodine, we make use of the following interface interface IndexedAPI < I , Ix > { fun I . asIx (): Hk < Ix , Unit > fun Hk < Ix , Unit > . asInterface (): I } to witness the relationship between an interface I , and it's \"indexed\" (or functorial) version Ix . Note that here, Hk<F,A> can be read as F<A> . For example: interface Calculator { fun enterNumber ( x : Int ) fun enterSymbol ( symbol : Symbol ) fun viewScreen (): String companion object { fun indexed (): IndexedAPI < Calculator , IxCalculator . W > { ... } } } interface IxCalculator < K > : Hk < IxCalculator . W , K > { object W fun enterNumber ( x : Int ): K fun enterSymbol ( symbol : Symbol ): K fun viewScreen (): Pair < String , K > } Composing Components Although, after parsing out the differences between Halogen's query parameter and Iodine's I , Iodine provides a very similar external API for components, a major different arises in how these APIs are used. Whereas Halogen enforces a tree-like hiearchy of components, with \"parent\" and \"child\" components, Iodine is not as strict -- and allows anyone with a reference to a Component<Ctx,I,E,A> to interact with it. Monadic effects Another difference between Iodine and Halogen is that whereas Halogen makes use of monads to model side-effecting computations, Iodine does not do so -- or rather, when it does , it does so in a slightly different way. Monads can be encoded in Kotlin using the same mechanism used above to encode higher-kinded types -- so why not make use of them in Iodine? Well, for one, the encoding of higher-kinded-types in Kotlin is currently rather tedious -- requiring manual wrapping and unwrapping to get the types to line up properly. Thus, we want to avoid using that encoding whenever possible . Additionally, Kotlin, unlike Purescript, is not a pure functional language. There is not a notion of a pure function that can be enforced by the compiler, and functions can produce arbitrary side-effects at any time. A function (A) -> B in Kotlin is like a -> Eff b in Purescript. However, that being said, even if one can already preform arbitrary side-effects in an Iodine comonent -- that does not mean that monads in general can not be of use. Iodine components still can have specified monadic effects -- we just don't call them that, and they look a little bit differently. So how does this work? Essentially, we use a similar idea as was used with I . We can encode additional effects (technically coeffects ) using an additional context parameter Ctx . For instance, if you need access to some service in your Iodine component, just extend IodineCtx with the appropriate interface, and use that as your Ctx parameter for your","title":"Halogen comparison"},{"location":"additional/halogen_comparison/#comparison-with-halogen","text":"If you're coming from Halogen , you will find Iodine very similar. Iodine takes a lot of cues from Halogen, but there are a few important differences to note.","title":"Comparison with Halogen"},{"location":"additional/halogen_comparison/#interfaces-as-query","text":"Veterans of Halogen are sure to notice the lack of the query parameter of H.Component in Iodine's components. That is because it has been replaced with an interaction interface I. Now, I know what some of you might be thinking: gasp ! * clutches functional pearls* -- How could one possibly replace the higher-kinded query : * -> * -> * with a simple interface? To which I respond: Don't worry -- this actually has a bit of precedent, and interesting theory behind it. So if you need to legitimize your functional street cred, just be sure to mention something about the \"van Laarhoven Free Monad\". Also, to be fair, we still do need higher kinds when defining the component -- let me explain. It turns out that the Kotlin type I.() -> A , where I is an interface, is almost like a free monad. This is not quite as powerful as the van Laarhoven encoding mentioned above, but close enough for our use-case of I as a parameter for describing the API for interacting with a typed comonent (hence, interaction interface ). Even better -- it turns out that I is pretty close to what we need in order to interpret our \"free-ish\" monad I.() -> A -- that is, a cofree comonad . However, this is where higher-kinds are nescesary for our use-case. In Iodine, we make use of the following interface interface IndexedAPI < I , Ix > { fun I . asIx (): Hk < Ix , Unit > fun Hk < Ix , Unit > . asInterface (): I } to witness the relationship between an interface I , and it's \"indexed\" (or functorial) version Ix . Note that here, Hk<F,A> can be read as F<A> . For example: interface Calculator { fun enterNumber ( x : Int ) fun enterSymbol ( symbol : Symbol ) fun viewScreen (): String companion object { fun indexed (): IndexedAPI < Calculator , IxCalculator . W > { ... } } } interface IxCalculator < K > : Hk < IxCalculator . W , K > { object W fun enterNumber ( x : Int ): K fun enterSymbol ( symbol : Symbol ): K fun viewScreen (): Pair < String , K > }","title":"Interfaces as query"},{"location":"additional/halogen_comparison/#composing-components","text":"Although, after parsing out the differences between Halogen's query parameter and Iodine's I , Iodine provides a very similar external API for components, a major different arises in how these APIs are used. Whereas Halogen enforces a tree-like hiearchy of components, with \"parent\" and \"child\" components, Iodine is not as strict -- and allows anyone with a reference to a Component<Ctx,I,E,A> to interact with it.","title":"Composing Components"},{"location":"additional/halogen_comparison/#monadic-effects","text":"Another difference between Iodine and Halogen is that whereas Halogen makes use of monads to model side-effecting computations, Iodine does not do so -- or rather, when it does , it does so in a slightly different way. Monads can be encoded in Kotlin using the same mechanism used above to encode higher-kinded types -- so why not make use of them in Iodine? Well, for one, the encoding of higher-kinded-types in Kotlin is currently rather tedious -- requiring manual wrapping and unwrapping to get the types to line up properly. Thus, we want to avoid using that encoding whenever possible . Additionally, Kotlin, unlike Purescript, is not a pure functional language. There is not a notion of a pure function that can be enforced by the compiler, and functions can produce arbitrary side-effects at any time. A function (A) -> B in Kotlin is like a -> Eff b in Purescript. However, that being said, even if one can already preform arbitrary side-effects in an Iodine comonent -- that does not mean that monads in general can not be of use. Iodine components still can have specified monadic effects -- we just don't call them that, and they look a little bit differently. So how does this work? Essentially, we use a similar idea as was used with I . We can encode additional effects (technically coeffects ) using an additional context parameter Ctx . For instance, if you need access to some service in your Iodine component, just extend IodineCtx with the appropriate interface, and use that as your Ctx parameter for your","title":"Monadic effects"},{"location":"additional/higher_kinds_in_kotlin/","text":"Higher kinded types in Kotlin Higher-kinded-types are a type of generic programing feature that allows for generic parameters like F to stand for not just types like Int or Double -- but types which take other types as arguments. The most common example often encounted is containers, like F = List , F = Sequence , or F = Map . Kotlin does not natively support such generic type parameters -- if you don't believe me, just try plugging just List (not List<A> , List<Int> , or List<*> -- just List ) into something expecting a generic parameter. Iodine makes use of these higher-kinded-types by making use of a lightweight encoding of this feature, as some features (such as making use of an interface I to define the type of interactions with a component) would be difficult to implement in a clean, declarative way without them. Additionally, Iodine makes use of some more experimental/advanced features by making use of this encoding. To allow for the highest level of interoperability with other frameworks using an encoding of Higher-kinded types in Kotlin/on the JVM, Iodine currently makes use of the kindedJ library in it's encoding. The core ideas of this approach are that: Hk<Fw,A> is a dummy \"tagging\" interface used to represent the higher-kinded application F<A> . The generic type F<A> should extend the interface Hk<Fw, A> . Due to sub-typing, this means that we can use an F<A> wherever an Hk<F.W, A> is expected in an API. Fw is a \"witness\" for the higher-kinded type F . In other words, a dummy object used to represent F as an argument to Hk (remember -- we can't use F itself, which is the whole point of this encoding). There is a \"witness function\", Hk<Fw,A>.fix(): F<A> that lets us do the conversion the other way around. This requires type-casting, but should be safe as long as for each Fw , there is only one F that implements Hk<Fw, A> . For example, to represent MyType as a higher-kind with the witness MyType.W : data class MyType < A > ( val someValue : A , val someOtherValue : A ): Hk < MyType . W , A > { // Witness for MyType object W } @Supress ( \"UncheckedCast\" ) fun Hk < MyType . W , A > . fix (): MyType < A > { return this as MyType < A > }","title":"Higher kinds in kotlin"},{"location":"additional/higher_kinds_in_kotlin/#higher-kinded-types-in-kotlin","text":"Higher-kinded-types are a type of generic programing feature that allows for generic parameters like F to stand for not just types like Int or Double -- but types which take other types as arguments. The most common example often encounted is containers, like F = List , F = Sequence , or F = Map . Kotlin does not natively support such generic type parameters -- if you don't believe me, just try plugging just List (not List<A> , List<Int> , or List<*> -- just List ) into something expecting a generic parameter. Iodine makes use of these higher-kinded-types by making use of a lightweight encoding of this feature, as some features (such as making use of an interface I to define the type of interactions with a component) would be difficult to implement in a clean, declarative way without them. Additionally, Iodine makes use of some more experimental/advanced features by making use of this encoding. To allow for the highest level of interoperability with other frameworks using an encoding of Higher-kinded types in Kotlin/on the JVM, Iodine currently makes use of the kindedJ library in it's encoding. The core ideas of this approach are that: Hk<Fw,A> is a dummy \"tagging\" interface used to represent the higher-kinded application F<A> . The generic type F<A> should extend the interface Hk<Fw, A> . Due to sub-typing, this means that we can use an F<A> wherever an Hk<F.W, A> is expected in an API. Fw is a \"witness\" for the higher-kinded type F . In other words, a dummy object used to represent F as an argument to Hk (remember -- we can't use F itself, which is the whole point of this encoding). There is a \"witness function\", Hk<Fw,A>.fix(): F<A> that lets us do the conversion the other way around. This requires type-casting, but should be safe as long as for each Fw , there is only one F that implements Hk<Fw, A> . For example, to represent MyType as a higher-kind with the witness MyType.W : data class MyType < A > ( val someValue : A , val someOtherValue : A ): Hk < MyType . W , A > { // Witness for MyType object W } @Supress ( \"UncheckedCast\" ) fun Hk < MyType . W , A > . fix (): MyType < A > { return this as MyType < A > }","title":"Higher kinded types in Kotlin"},{"location":"concepts/basic_concepts/","text":"Basic Concepts The two basic concepts that Iodine makes use of is that of a Component , and that of a View Model . Roughly speaking, a Component is reusable bundle of behavior and a view (i.e. a @Composable fun ) of that behavior's internal state . Oftentimes, it may be convinient to keep the \"pure\" UI behavior logic decoupled from the actual way in which such logic is rendered -- for this purpose, we have the concept of a ViewModel . A ViewModel is pretty much what it sounds like -- a model of a view, or in our case a Component . View models and Components To start, let's dig into how Iodine defines a ViewModel : interface Settable < in A > { fun setValue ( newValue : A ) { } } interface ViewModel < out I , out E , S , in A > : Settable < A > { val impl : I val events : Flow < E > val state : StateFlow < S > } Theoretically, Iodine could have just gotten away with using I here -- as most view models as used in UI design patterns such as Model-View-ViewModel are just plain old interfaces. However, for convinience, we decided to break up the idea of a view model into three distinct components: I : The \"core\" interface of the ViewModel -- this should be an interface that describes methods that can be used to interact with the view model. E : The type of events that this view model can emit asynchronously at any time. Again, this could be construed as just another method of I -- but as this is such a common feature of view models, we reify the type E as a seperate part of the API. S : The type of internal state used by the view model. Usually, in a traditional view model, this would be a private part of the implementation of the API. However, for an Iodine ViewModel , we expose this inner state as a reactive StateFlow<S> so this view model can be bound to a rendering function to produce a full Component . Component s are just like view models, but together with a function for rendering the state of the ViewModel . Once a ViewModel has been bound to a mechanism for rendering it's state, there is no longer a reason to care about the state type S . Thus, whereas a ComponentImpl is defined as follows: interface ComponentImpl < out Ctx , out I , out E , S , in A > : ViewModel < I , E , S , A > { @Composable fun contents ( state : S ) } most of the time we want to use a Component , we want to keep the internal state S encapsulated . This can be accomplished with a star projection, which is how Iodine defines an honest-to-goodness Component : typealias Component < Ctx , I , E , A > = ComponentImpl < Ctx , I , E , * , A >","title":"Basic concepts"},{"location":"concepts/basic_concepts/#basic-concepts","text":"The two basic concepts that Iodine makes use of is that of a Component , and that of a View Model . Roughly speaking, a Component is reusable bundle of behavior and a view (i.e. a @Composable fun ) of that behavior's internal state . Oftentimes, it may be convinient to keep the \"pure\" UI behavior logic decoupled from the actual way in which such logic is rendered -- for this purpose, we have the concept of a ViewModel . A ViewModel is pretty much what it sounds like -- a model of a view, or in our case a Component .","title":"Basic Concepts"},{"location":"concepts/basic_concepts/#view-models-and-components","text":"To start, let's dig into how Iodine defines a ViewModel : interface Settable < in A > { fun setValue ( newValue : A ) { } } interface ViewModel < out I , out E , S , in A > : Settable < A > { val impl : I val events : Flow < E > val state : StateFlow < S > } Theoretically, Iodine could have just gotten away with using I here -- as most view models as used in UI design patterns such as Model-View-ViewModel are just plain old interfaces. However, for convinience, we decided to break up the idea of a view model into three distinct components: I : The \"core\" interface of the ViewModel -- this should be an interface that describes methods that can be used to interact with the view model. E : The type of events that this view model can emit asynchronously at any time. Again, this could be construed as just another method of I -- but as this is such a common feature of view models, we reify the type E as a seperate part of the API. S : The type of internal state used by the view model. Usually, in a traditional view model, this would be a private part of the implementation of the API. However, for an Iodine ViewModel , we expose this inner state as a reactive StateFlow<S> so this view model can be bound to a rendering function to produce a full Component . Component s are just like view models, but together with a function for rendering the state of the ViewModel . Once a ViewModel has been bound to a mechanism for rendering it's state, there is no longer a reason to care about the state type S . Thus, whereas a ComponentImpl is defined as follows: interface ComponentImpl < out Ctx , out I , out E , S , in A > : ViewModel < I , E , S , A > { @Composable fun contents ( state : S ) } most of the time we want to use a Component , we want to keep the internal state S encapsulated . This can be accomplished with a star projection, which is how Iodine defines an honest-to-goodness Component : typealias Component < Ctx , I , E , A > = ComponentImpl < Ctx , I , E , * , A >","title":"View models and Components"},{"location":"concepts/comonadic_components/","text":"Comonadic Components Now that we've introduced the basic idea of what a component is in Iodine, let's take a look at how comonads ome into the picture. For those not interested in the theory, continue on to the subsections of this section to see some examples of how this can be used. A comonad is a mathematical concept from category theory which has found many application in both theoretical computer science and practical programming applications. Like many abstract mathematical concepts, comonads can be thought of in many ways . For our purposes here, comonads can be thought of as an abstraction of somthing that: Holds onto a state. Has a way of updating that state. For a more in-deth explination, and similar view of comonads, see Comonads as Spaces . In Iodine, a Comonad is defined as a container F with methods: interface Comonad < W > : Functor < W > { val state : Hk < W , S > . S fun Hk < W , S > . duplicate (): Hk < W , Hk < W , S >> } where state gets the current state of the comonad, and duplicate encodes a way of denoting possible \"future states\" (how this is accomplished will be more clear later, with some concrete examples). A comonadic component then, is a component whose internal state and state transitions are modeled via a comonad . As it turns out, all components in Iodine are in fact comonadic -- but to avoid added complexity, this fact is hidden from the user unless they would like to explicitly explore this approach to modeling user interfaces. Store Components One of the most basic examples of a comonad is the Store comonad. The type itself is defined as follows: data class Store < X , S > ( val internalState : X , val view : ( X ) -> S ) Essentially a store is something that holds onto an internal state X , and \"exposes\" a computed view of that state with the supplied function. For instance: data class Person ( val name : String , val age : Int ) val personNameStore = Store ( internalState = Person ( \"Bob\" , 42 ), view = { person -> person . name } ) The state of a Store is just applying the view to the internalState to get the publicly exposed state: val Store < X , S > . state : S = view ( internalState ) The duplicate operation is defined as follows: fun Store < X , S > . duplicate (): Store < X , Store < X , S >> { val currentStore = this return Store ( internalState = currentStore . internalState , view = { nextState -> Store ( internalState = nextState , view = currentStore . view ) } ) } So in other words, if we view a duplicated state with a new internalState , we get an updated Store that \"stores\" that new state, with the same view as before. This is how duplicate can be used to transition a Store to a new state. The method for updating the state of a Store is to just pass in a new internal state. Thus, a StoreComponent is just a component holding on to some state S that can be updated to any value. There are no complicated state transitions to contend with. For this reason, StoreComponents are good at modeling things like basic entry forms that just \"hold on\" to some entered value. In fact, by exposing the internal state, together with the \"viewed\" state -- we can take another perspective on comonadic store components entirely by viewing these parameters as the type of inputs and outputs to the component -- A , B . This turns out to be the most useful application of Store components in Iodine -- so we give a name to this concept: A Form . Exposing these two parameters rather than simply an input parameter, as is done with normal Iodine components gives us an instance of another important mathematical struture -- that of the Profunctor . This is all explained in greater detail, with examples, in the section on Form s . Moore Components Our next example allows for the modeling of some more complicated state transitions in a Component , and actually corresponds to something close to the original design of Iodine -- as well as being similar to the Elm Architecture . The Moore comonad -- so named because it acts similarly to a finite state machine called a Moore machine -- is defined as follows: data class Moore < E , A > ( val value : A , val next : ( E ) -> Moore < E , A > ) So again, a Moore comonad holds on to a \"current state\" with value . However, unlike the Store comonad, it also comes equipped with a transition function next which depending on an event E , will return a new state of the Moore machine ( Moore<E, A> ) according to the event passed in. Note that the \"event\" here is different from the usual E parameter of an Iodine Component , which is a type of event that the component can asynchronously output -- so to distinguish between the two, we use the convention of Ei as a \"input event\" and Eo as an \"output event\". Let's look at a simple example of defining a component using this type of architecture defined by the Moore comonad: /** * The Elm Arctitecture (a.k.a. Model-View-Update) in Iodine. * * Compare with https://elm-lang.org/examples/buttons * */ // Model value class Model ( val count : Int ) enum class Msg { Increment , Decrement } object CounterComponent : MooreComponentImpl < IodineContext , Msg , Void , Model , Model > ( initialState = Model ( 0 ) ) { // View @Composable override fun C . render ( state : S ) { Column { Text ( \"Hello MVU!\" ) Button ( text = \"-\" , onClick = { emit ( Msg . Decrement ) }) Text ( state . count . toString ()) Button ( text = \"+\" , onClick = { emit ( Msg . Increment ) }) } } // Update override fun reducer ( event : Msg , state : Model ): Model = when ( event ) { Msg . Increment -> Model ( state . count + 1 ) Msg . Decrement -> Model ( state . count - 1 ) } } Cofree Components The most flexible of the comonadic components defined by Iodine is that of a Cofree component. Unlike the other comonads we have seen, Cofree takes a higher-kinded parameter F : data class Cofree < F , A > ( val state : A , val next : Hk < F , Cofree < F , A >> ) Again, like the others, a Cofree holds on to a state -- but it's next parameter takes an an application of F to control how the \"next states\" branch out. Combining Components So far, all of the types of comonadic components we have seen all have concrete representations as interfaces or abstract classes in the core iodine package. What then is the use of having a generic ComonadicComponent interface hanging around (besides just being good fun and interesting for those who enjoy Category Theory)? The answer lies in the different ways that one can combine comonads. As a bit of a teaser, you can think of a complex combination of comonads as giving you something similar to a statically-typed version of a UI testing framework like Selenium or Espresso . To begin, meet Day : interface Day < F , G , A > : Hk < Day . W < F , G > , A > { class W < F , G > fun < B , C > runDay ( x : Hk < F , B > , y : Hk < G , C > , f : ( B , C ) -> A ): A } If this implementation doesn't make sense -- that's fine! It'll probably take some time playing around with examples to get an intuition for how this works \"under the hood\" -- but at a high-level: Day gives us a way of embedding two comonads F , G into a larger comonad Day<F,G> where at any point in time, you can manipulate the state of Day<F,G,S> by either making use of the API provided by F or by making use of the API provided by G . Testing a Comonadic API Now that we've seen a few different ways of combining comonadic components -- let's look at some examples of how we can use these ideas in testing. Let's say you're building an app for managing recipes, and you want to build an automated UI test to see what happens when you try to add a recipe with the same name as one that you already have saved. This App's main activity can be broken down into two high-level components -- a MyRecipeAppBar and a MyRecipesView . Let's look at what sort of APIs they provide. object MyRecipeAppBar : ComponentDescription < ActivityCtx , MyRecipeAppBar . Action , MyRecipeAppBar . Event , Unit > { interface Action { /** Add the given recipe to the app. */ fun addRecipe ( recipe : Recipe ) /** Navigates the user to the preference activty. */ fun openPreferences () } sealed interface Event { /** * Event emitted whenever a recipe is imported into the app. * * Examples: * User manually enters in a new recipe. * User imports a recipe via the \"share\" feature of another app. */ data class OnRecipeAdded ( val recipe : Recipe ) } ... } object MyRecipesView : ComponentDescription < ActivityCtx , MyRecipesView . Action , Void , Unit > { interface Action { /** Sort the list of recipes in the app by the given strategy. */ fun sortRecipes ( by : SortingStrategy ) /** Get the list of recipes in the view in the current sorted order. */ fun getRecipes (): List < Recipe > /** Remove a recipe from the app. Returns false on failure. */ fun removeRecipe ( recipe : Recipe ): Boolean } ... }","title":"Comonadic components"},{"location":"concepts/comonadic_components/#comonadic-components","text":"Now that we've introduced the basic idea of what a component is in Iodine, let's take a look at how comonads ome into the picture. For those not interested in the theory, continue on to the subsections of this section to see some examples of how this can be used. A comonad is a mathematical concept from category theory which has found many application in both theoretical computer science and practical programming applications. Like many abstract mathematical concepts, comonads can be thought of in many ways . For our purposes here, comonads can be thought of as an abstraction of somthing that: Holds onto a state. Has a way of updating that state. For a more in-deth explination, and similar view of comonads, see Comonads as Spaces . In Iodine, a Comonad is defined as a container F with methods: interface Comonad < W > : Functor < W > { val state : Hk < W , S > . S fun Hk < W , S > . duplicate (): Hk < W , Hk < W , S >> } where state gets the current state of the comonad, and duplicate encodes a way of denoting possible \"future states\" (how this is accomplished will be more clear later, with some concrete examples). A comonadic component then, is a component whose internal state and state transitions are modeled via a comonad . As it turns out, all components in Iodine are in fact comonadic -- but to avoid added complexity, this fact is hidden from the user unless they would like to explicitly explore this approach to modeling user interfaces.","title":"Comonadic Components"},{"location":"concepts/comonadic_components/#store-components","text":"One of the most basic examples of a comonad is the Store comonad. The type itself is defined as follows: data class Store < X , S > ( val internalState : X , val view : ( X ) -> S ) Essentially a store is something that holds onto an internal state X , and \"exposes\" a computed view of that state with the supplied function. For instance: data class Person ( val name : String , val age : Int ) val personNameStore = Store ( internalState = Person ( \"Bob\" , 42 ), view = { person -> person . name } ) The state of a Store is just applying the view to the internalState to get the publicly exposed state: val Store < X , S > . state : S = view ( internalState ) The duplicate operation is defined as follows: fun Store < X , S > . duplicate (): Store < X , Store < X , S >> { val currentStore = this return Store ( internalState = currentStore . internalState , view = { nextState -> Store ( internalState = nextState , view = currentStore . view ) } ) } So in other words, if we view a duplicated state with a new internalState , we get an updated Store that \"stores\" that new state, with the same view as before. This is how duplicate can be used to transition a Store to a new state. The method for updating the state of a Store is to just pass in a new internal state. Thus, a StoreComponent is just a component holding on to some state S that can be updated to any value. There are no complicated state transitions to contend with. For this reason, StoreComponents are good at modeling things like basic entry forms that just \"hold on\" to some entered value. In fact, by exposing the internal state, together with the \"viewed\" state -- we can take another perspective on comonadic store components entirely by viewing these parameters as the type of inputs and outputs to the component -- A , B . This turns out to be the most useful application of Store components in Iodine -- so we give a name to this concept: A Form . Exposing these two parameters rather than simply an input parameter, as is done with normal Iodine components gives us an instance of another important mathematical struture -- that of the Profunctor . This is all explained in greater detail, with examples, in the section on Form s .","title":"Store Components"},{"location":"concepts/comonadic_components/#moore-components","text":"Our next example allows for the modeling of some more complicated state transitions in a Component , and actually corresponds to something close to the original design of Iodine -- as well as being similar to the Elm Architecture . The Moore comonad -- so named because it acts similarly to a finite state machine called a Moore machine -- is defined as follows: data class Moore < E , A > ( val value : A , val next : ( E ) -> Moore < E , A > ) So again, a Moore comonad holds on to a \"current state\" with value . However, unlike the Store comonad, it also comes equipped with a transition function next which depending on an event E , will return a new state of the Moore machine ( Moore<E, A> ) according to the event passed in. Note that the \"event\" here is different from the usual E parameter of an Iodine Component , which is a type of event that the component can asynchronously output -- so to distinguish between the two, we use the convention of Ei as a \"input event\" and Eo as an \"output event\". Let's look at a simple example of defining a component using this type of architecture defined by the Moore comonad: /** * The Elm Arctitecture (a.k.a. Model-View-Update) in Iodine. * * Compare with https://elm-lang.org/examples/buttons * */ // Model value class Model ( val count : Int ) enum class Msg { Increment , Decrement } object CounterComponent : MooreComponentImpl < IodineContext , Msg , Void , Model , Model > ( initialState = Model ( 0 ) ) { // View @Composable override fun C . render ( state : S ) { Column { Text ( \"Hello MVU!\" ) Button ( text = \"-\" , onClick = { emit ( Msg . Decrement ) }) Text ( state . count . toString ()) Button ( text = \"+\" , onClick = { emit ( Msg . Increment ) }) } } // Update override fun reducer ( event : Msg , state : Model ): Model = when ( event ) { Msg . Increment -> Model ( state . count + 1 ) Msg . Decrement -> Model ( state . count - 1 ) } }","title":"Moore Components"},{"location":"concepts/comonadic_components/#cofree-components","text":"The most flexible of the comonadic components defined by Iodine is that of a Cofree component. Unlike the other comonads we have seen, Cofree takes a higher-kinded parameter F : data class Cofree < F , A > ( val state : A , val next : Hk < F , Cofree < F , A >> ) Again, like the others, a Cofree holds on to a state -- but it's next parameter takes an an application of F to control how the \"next states\" branch out.","title":"Cofree Components"},{"location":"concepts/comonadic_components/#combining-components","text":"So far, all of the types of comonadic components we have seen all have concrete representations as interfaces or abstract classes in the core iodine package. What then is the use of having a generic ComonadicComponent interface hanging around (besides just being good fun and interesting for those who enjoy Category Theory)? The answer lies in the different ways that one can combine comonads. As a bit of a teaser, you can think of a complex combination of comonads as giving you something similar to a statically-typed version of a UI testing framework like Selenium or Espresso . To begin, meet Day : interface Day < F , G , A > : Hk < Day . W < F , G > , A > { class W < F , G > fun < B , C > runDay ( x : Hk < F , B > , y : Hk < G , C > , f : ( B , C ) -> A ): A } If this implementation doesn't make sense -- that's fine! It'll probably take some time playing around with examples to get an intuition for how this works \"under the hood\" -- but at a high-level: Day gives us a way of embedding two comonads F , G into a larger comonad Day<F,G> where at any point in time, you can manipulate the state of Day<F,G,S> by either making use of the API provided by F or by making use of the API provided by G .","title":"Combining Components"},{"location":"concepts/comonadic_components/#testing-a-comonadic-api","text":"Now that we've seen a few different ways of combining comonadic components -- let's look at some examples of how we can use these ideas in testing. Let's say you're building an app for managing recipes, and you want to build an automated UI test to see what happens when you try to add a recipe with the same name as one that you already have saved. This App's main activity can be broken down into two high-level components -- a MyRecipeAppBar and a MyRecipesView . Let's look at what sort of APIs they provide. object MyRecipeAppBar : ComponentDescription < ActivityCtx , MyRecipeAppBar . Action , MyRecipeAppBar . Event , Unit > { interface Action { /** Add the given recipe to the app. */ fun addRecipe ( recipe : Recipe ) /** Navigates the user to the preference activty. */ fun openPreferences () } sealed interface Event { /** * Event emitted whenever a recipe is imported into the app. * * Examples: * User manually enters in a new recipe. * User imports a recipe via the \"share\" feature of another app. */ data class OnRecipeAdded ( val recipe : Recipe ) } ... } object MyRecipesView : ComponentDescription < ActivityCtx , MyRecipesView . Action , Void , Unit > { interface Action { /** Sort the list of recipes in the app by the given strategy. */ fun sortRecipes ( by : SortingStrategy ) /** Get the list of recipes in the view in the current sorted order. */ fun getRecipes (): List < Recipe > /** Remove a recipe from the app. Returns false on failure. */ fun removeRecipe ( recipe : Recipe ): Boolean } ... }","title":"Testing a Comonadic API"},{"location":"concepts/forms_and_profunctors/","text":"Profunctors In addition to comonads, another concept from the pure functional programming community that Iodine makes use of is that of profunctors and profunctor optics . Profunctors are a generalization of functions. Essentially, they can be thought of as objects with an \"input type\", and an \"output type\" -- where these input and output types can be \"adapted\" by providing the appropriate type of function. interface Profunctor < P > { fun Hk2 < P , A , B > . lmap ( f : ( X ) -> A ): Hk2 < P , X , B > fun Hk2 < P , A , B > . rmap ( f : ( B ) -> X ): Hk2 < P , A , X > } Forms For every Component interface in Iodine, such as ComponentImpl , MooreComponent , and so on -- there is a comporresponding interface for a Form that extends the given notion of a component with an output type . This interface is incredibly useful for components used for data entry -- hence the name. Forms will have all the same generic parameters as Components, plus an additional one for it's output type. So, for instance, something like Form<Ctx,I,E,A,B> , rather than Component<Ctx,I,E,A> . Defining forms this way allows us to view forms as an important example of a Profunctor , as witnessed by the lmap and rmap methods defined for such forms. Profunctor optics Optics are usually concieved as a type of modular data accessor_s for immutable data structures in functional languages. However, optics also have another side less seen -- and this can be seen through the lens (pun intended) of _profunctor optics . ... Applications of Profunctor Optics to Forms ...","title":"Forms and profunctors"},{"location":"concepts/forms_and_profunctors/#profunctors","text":"In addition to comonads, another concept from the pure functional programming community that Iodine makes use of is that of profunctors and profunctor optics . Profunctors are a generalization of functions. Essentially, they can be thought of as objects with an \"input type\", and an \"output type\" -- where these input and output types can be \"adapted\" by providing the appropriate type of function. interface Profunctor < P > { fun Hk2 < P , A , B > . lmap ( f : ( X ) -> A ): Hk2 < P , X , B > fun Hk2 < P , A , B > . rmap ( f : ( B ) -> X ): Hk2 < P , A , X > }","title":"Profunctors"},{"location":"concepts/forms_and_profunctors/#forms","text":"For every Component interface in Iodine, such as ComponentImpl , MooreComponent , and so on -- there is a comporresponding interface for a Form that extends the given notion of a component with an output type . This interface is incredibly useful for components used for data entry -- hence the name. Forms will have all the same generic parameters as Components, plus an additional one for it's output type. So, for instance, something like Form<Ctx,I,E,A,B> , rather than Component<Ctx,I,E,A> . Defining forms this way allows us to view forms as an important example of a Profunctor , as witnessed by the lmap and rmap methods defined for such forms.","title":"Forms"},{"location":"concepts/forms_and_profunctors/#profunctor-optics","text":"Optics are usually concieved as a type of modular data accessor_s for immutable data structures in functional languages. However, optics also have another side less seen -- and this can be seen through the lens (pun intended) of _profunctor optics . ...","title":"Profunctor optics"},{"location":"concepts/forms_and_profunctors/#applications-of-profunctor-optics-to-forms","text":"...","title":"Applications of Profunctor Optics to Forms"},{"location":"concepts/tools/","text":"Tools Beyond components and forms, the next important concept in Iodine is that of a Tool . Whereas Component s can be thought of as an enhanced @Composable function -- Tool s can be thought of as enhanced suspend functions. interface Tool < in C : IodineContext , out E , out A > { val events : Flow < E > suspend fun runTool ( ctx : C ): A } Similarly to Component s, Tool s make use of a context parameter extending IodineContext that can be used to provide basic dependencies needed for UI manipulation, as well as potentially other relevant data via functional dependency injection (although, once Kotlin gets context receivers, that will become less important). Additionally, Tool s come equipped with an event parameter E for events that may be asynchrounously emitted while the tool is running. Tool s are generally meant to be used for actions that manipulate the surrounding user interface, prompt the user to preform some set of actions, and then eventually to return a result (the key word eventually being why we make runTool a suspend fun . For example, a modal dialog adds a dialog to the current window (or screen, or page -- depending on platform), potentially prompts the user to enter in some data, or to manipulate some widgets in the dialog, and then eventually to select one of the buttons of the dialog to close it out (for instance, \"Ok\" or \"Cancel\"). Again, much like components, Tool s also come in a ToolDescription flavor. ToolDescription s add an input parameter and so are defined as follows: typealias ToolDescription < C , E , A , B > = Description < C , A , Tool < C , E , B >> Composing tools By invoking the companion object of Tool , we can combine mutliple ToolDescription s in sequence monadically by using .bind() . Tool { val res = ModalPrompt ( \"Click OK to get a toast!\" ). bind () if ( res != null ) { Toast ( \"Here's your toast.\" ). bind () } } Iodine also provides a set of additional monadic comprehensions for tools returning nullable and Either results. Finally, Iodine also provides a set of primitive functions for combining tools, such as compose and thenTool . However, we supsect that in most cases, the monad comprehension syntax will be the most convinient and readable. The duality of tools and components In the section on comonadic components, we saw that each comonad W has an associated \"dual\" monad M which allows us to define an operation fun <A> W<A>.explore(action: M<Unit>): W<A> which lets us preform a set of actions that manipulates the state of the comonad W<A> to return a new comonad representing the new state of the comonad after preforming the given actions. As it turns out, there is a dual way of viewing this duality between Monads and Comonads. However, this is (as far as the author knows at the time of writing) not as well studied, so for the time being, we will simply look at an example of this phenomenon. Recall that with components, we have an \"interaction interface\" I to fill in for the action monad M which acts as a kind of \"controller\" or \"view model\" for the component that manipulates it's state. Can something similar be done for tools? The answer is: Yes. ...","title":"Tools"},{"location":"concepts/tools/#tools","text":"Beyond components and forms, the next important concept in Iodine is that of a Tool . Whereas Component s can be thought of as an enhanced @Composable function -- Tool s can be thought of as enhanced suspend functions. interface Tool < in C : IodineContext , out E , out A > { val events : Flow < E > suspend fun runTool ( ctx : C ): A } Similarly to Component s, Tool s make use of a context parameter extending IodineContext that can be used to provide basic dependencies needed for UI manipulation, as well as potentially other relevant data via functional dependency injection (although, once Kotlin gets context receivers, that will become less important). Additionally, Tool s come equipped with an event parameter E for events that may be asynchrounously emitted while the tool is running. Tool s are generally meant to be used for actions that manipulate the surrounding user interface, prompt the user to preform some set of actions, and then eventually to return a result (the key word eventually being why we make runTool a suspend fun . For example, a modal dialog adds a dialog to the current window (or screen, or page -- depending on platform), potentially prompts the user to enter in some data, or to manipulate some widgets in the dialog, and then eventually to select one of the buttons of the dialog to close it out (for instance, \"Ok\" or \"Cancel\"). Again, much like components, Tool s also come in a ToolDescription flavor. ToolDescription s add an input parameter and so are defined as follows: typealias ToolDescription < C , E , A , B > = Description < C , A , Tool < C , E , B >>","title":"Tools"},{"location":"concepts/tools/#composing-tools","text":"By invoking the companion object of Tool , we can combine mutliple ToolDescription s in sequence monadically by using .bind() . Tool { val res = ModalPrompt ( \"Click OK to get a toast!\" ). bind () if ( res != null ) { Toast ( \"Here's your toast.\" ). bind () } } Iodine also provides a set of additional monadic comprehensions for tools returning nullable and Either results. Finally, Iodine also provides a set of primitive functions for combining tools, such as compose and thenTool . However, we supsect that in most cases, the monad comprehension syntax will be the most convinient and readable.","title":"Composing tools"},{"location":"concepts/tools/#the-duality-of-tools-and-components","text":"In the section on comonadic components, we saw that each comonad W has an associated \"dual\" monad M which allows us to define an operation fun <A> W<A>.explore(action: M<Unit>): W<A> which lets us preform a set of actions that manipulates the state of the comonad W<A> to return a new comonad representing the new state of the comonad after preforming the given actions. As it turns out, there is a dual way of viewing this duality between Monads and Comonads. However, this is (as far as the author knows at the time of writing) not as well studied, so for the time being, we will simply look at an example of this phenomenon. Recall that with components, we have an \"interaction interface\" I to fill in for the action monad M which acts as a kind of \"controller\" or \"view model\" for the component that manipulates it's state. Can something similar be done for tools? The answer is: Yes. ...","title":"The duality of tools and components"},{"location":"examples/basic_examples/","text":"Examples Building a basic component Input validation One common problem often that has to be addressed when building graphical user interfaces is how to handle form input validation . Iodine provides a couple of utility classes for dealing with exactly this problem. For example, consider the following example for how to build a component with input validation for a textbox entry for an integer. // Example Component object : ValidatingStoreComponent < String , Int , InvalidInteger > ( initialValue ) { override fun view ( input : String ) = input . toIntOrNull () ?. let { Either . Right ( it ) } ?: Either . Left ( InvalidInteger ) @Composable override fun contents ( error : InvalidInteger?, contents : String ) { Column { TextField ( value = contents , onValueChange = { newValue -> ctx . defaultScope . launch { mutInput . emit ( newValue ) } }, label = { Text ( \"\" ) } ) if ( error == InvalidInteger ) { Text ( text = \"Not a valid integer\" , color = Color . Red , fontSize = 16. sp ) } } Combining components The easiest way to combine smaller components into larger components in Iodine is to make use of one of the provided builders . For components which are not Form s -- you'll generally want to make use of ComponentBuilder . For combining Form s, a little bit more care is needed. Currently Iodine only directly supports building up forms whose input and output types are immutable data classes. For such cases, we can make use of the buildable-kt library. buildable-kt comes with an annotation @GenBuildable , which can be applied to a data class in order to automatically generate an implementation of the Buildable interface that Iodine needs in order to be able to construct a form for a complete type from smaller forms that are used for inputting it's constituent peices. To illustrate this, let's look at an example of how buildable-kt can be used alongside Iodine's FormBuilder to build up a form: @GenBuildable data class Person ( val name : String , val age : Int ) { companion object { } } object PersonForm : SFormDescription < IodineCtx , Person > by ( FormBuilder { } )","title":"Basic examples"},{"location":"examples/basic_examples/#examples","text":"","title":"Examples"},{"location":"examples/basic_examples/#building-a-basic-component","text":"","title":"Building a basic component"},{"location":"examples/basic_examples/#input-validation","text":"One common problem often that has to be addressed when building graphical user interfaces is how to handle form input validation . Iodine provides a couple of utility classes for dealing with exactly this problem. For example, consider the following example for how to build a component with input validation for a textbox entry for an integer. // Example Component object : ValidatingStoreComponent < String , Int , InvalidInteger > ( initialValue ) { override fun view ( input : String ) = input . toIntOrNull () ?. let { Either . Right ( it ) } ?: Either . Left ( InvalidInteger ) @Composable override fun contents ( error : InvalidInteger?, contents : String ) { Column { TextField ( value = contents , onValueChange = { newValue -> ctx . defaultScope . launch { mutInput . emit ( newValue ) } }, label = { Text ( \"\" ) } ) if ( error == InvalidInteger ) { Text ( text = \"Not a valid integer\" , color = Color . Red , fontSize = 16. sp ) } }","title":"Input validation"},{"location":"examples/basic_examples/#combining-components","text":"The easiest way to combine smaller components into larger components in Iodine is to make use of one of the provided builders . For components which are not Form s -- you'll generally want to make use of ComponentBuilder . For combining Form s, a little bit more care is needed. Currently Iodine only directly supports building up forms whose input and output types are immutable data classes. For such cases, we can make use of the buildable-kt library. buildable-kt comes with an annotation @GenBuildable , which can be applied to a data class in order to automatically generate an implementation of the Buildable interface that Iodine needs in order to be able to construct a form for a complete type from smaller forms that are used for inputting it's constituent peices. To illustrate this, let's look at an example of how buildable-kt can be used alongside Iodine's FormBuilder to build up a form: @GenBuildable data class Person ( val name : String , val age : Int ) { companion object { } } object PersonForm : SFormDescription < IodineCtx , Person > by ( FormBuilder { } )","title":"Combining components"},{"location":"examples/calculator_app/","text":"Building a calculator app","title":"Calculator app"},{"location":"examples/calculator_app/#building-a-calculator-app","text":"","title":"Building a calculator app"},{"location":"examples/todo_app/","text":"Building a Todo app","title":"Todo app"},{"location":"examples/todo_app/#building-a-todo-app","text":"","title":"Building a Todo app"}]}